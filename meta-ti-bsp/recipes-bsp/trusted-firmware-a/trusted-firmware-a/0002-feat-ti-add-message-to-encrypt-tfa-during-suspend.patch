From c79ff3679a4360bb848b01d4036c365533fcf791 Mon Sep 17 00:00:00 2001
From: Richard Genoud <richard.genoud@bootlin.com>
Date: Tue, 11 Feb 2025 18:20:17 +0100
Subject: [PATCH 2/3] feat(ti): add message to encrypt tfa during suspend

At suspend, BL31 with its context will be encrypted by TIFS in DDR.
Encryption is needed for security matters, so that the BL31 is not
modified before entering suspend or early at resume.

We only need the encryption function here because the decryption message
will be send by the R5 SPL at resume.

Also introduce the LPM_ENCRYPT_IMAGE cap signals that FW has the support
to encrypt the image using the TISCI_MSG_LPM_ENCRYPT tisci message.

This is useful in suspend to ram cases where we would like to
store the encrypted image of a secure fw instead of the original image
itself in the DDR.

Check for LPM_ENCRYPT_IMAGE flag in the FW capabilities, and only then
call encrypt.

Upstream-Status: Pending

Change-Id: I266472da87dd0821493019b2d9853f8886f33811
Signed-off-by: Richard Genoud <richard.genoud@bootlin.com>
Signed-off-by: Abhash Kumar Jha <a-kumar2@ti.com>
---
 drivers/ti/ti_sci/ti_sci.c          | 36 +++++++++++++++++++++++++++++
 drivers/ti/ti_sci/ti_sci.h          |  7 ++++++
 drivers/ti/ti_sci/ti_sci_protocol.h | 32 +++++++++++++++++++++++++
 plat/ti/k3/common/k3_psci.c         | 10 ++++++++
 4 files changed, 85 insertions(+)

diff --git a/drivers/ti/ti_sci/ti_sci.c b/drivers/ti/ti_sci/ti_sci.c
index f0813e5b0..ee5f7166f 100644
--- a/drivers/ti/ti_sci/ti_sci.c
+++ b/drivers/ti/ti_sci/ti_sci.c
@@ -1784,3 +1784,39 @@ int ti_sci_lpm_get_next_sys_mode(uint8_t *next_mode)

	return 0;
 }
+/*
+ * ti_sci_encrypt_tfa - Ask TIFS to encrypt TFA at a specific address
+ *
+ * @src_tfa_addr: Address where the TFA lies unencrypted
+ * @src_tfa_len: Size of the TFA unencrypted
+ *
+ * Return: 0 if all goes well, else appropriate error message
+ */
+int ti_sci_encrypt_tfa(uint64_t src_tfa_addr,
+		       uint32_t src_tfa_len)
+{
+	struct ti_sci_msg_req_encrypt_tfa req = { 0 };
+	struct ti_sci_msg_resp_encrypt_tfa resp = { 0 };
+	struct ti_sci_xfer xfer;
+	int ret;
+
+	ret = ti_sci_setup_one_xfer(TISCI_MSG_LPM_ENCRYPT_TFA, 0,
+				    &req, sizeof(req),
+				    &resp, sizeof(resp),
+				    &xfer);
+	if (ret != 0U) {
+		ERROR("Message alloc failed (%d)\n", ret);
+		return ret;
+	}
+
+	req.src_tfa_addr = src_tfa_addr;
+	req.src_tfa_len = src_tfa_len;
+
+	ret = ti_sci_do_xfer(&xfer);
+	if (ret != 0U) {
+		ERROR("Transfer send failed (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/ti/ti_sci/ti_sci.h b/drivers/ti/ti_sci/ti_sci.h
index 1f1963274..2afa11317 100644
--- a/drivers/ti/ti_sci/ti_sci.h
+++ b/drivers/ti/ti_sci/ti_sci.h
@@ -258,6 +258,11 @@ int ti_sci_proc_wait_boot_status_no_wait(uint8_t proc_id,
  *
  * Return: 0 if all goes well, else appropriate error message
  *
+ * - ti_sci_encrypt_tfa - Ask TIFS to encrypt TFA at a specific address
+ *
+ *		@src_tfa_addr: Address where the TFA lies unencrypted
+ *		@src_tfa_len: Size of the TFA unencrypted
+ *
  * NOTE: for all these functions, the following are generic in nature:
  * Returns 0 for successful request, else returns corresponding error message.
  */
@@ -265,5 +270,7 @@ int ti_sci_enter_sleep(uint8_t proc_id,
		       uint8_t mode,
		       uint64_t core_resume_addr);
 int ti_sci_lpm_get_next_sys_mode(uint8_t *next_mode);
+int ti_sci_encrypt_tfa(uint64_t src_tfa_addr,
+		       uint32_t src_tfa_len);

 #endif /* TI_SCI_H */
diff --git a/drivers/ti/ti_sci/ti_sci_protocol.h b/drivers/ti/ti_sci/ti_sci_protocol.h
index bdd24622a..a165cda99 100644
--- a/drivers/ti/ti_sci/ti_sci_protocol.h
+++ b/drivers/ti/ti_sci/ti_sci_protocol.h
@@ -53,6 +53,9 @@
 #define TISCI_MSG_GET_PROC_BOOT_STATUS	0xc400
 #define TISCI_MSG_WAIT_PROC_BOOT_STATUS	0xc401

+/* TFA encrypt/decrypt messages */
+#define TISCI_MSG_LPM_ENCRYPT_TFA	0x030F
+
 /**
  * struct ti_sci_secure_msg_hdr - Header that prefixes all TISCI messages sent
  *				  via secure transport.
@@ -160,6 +163,7 @@ struct ti_sci_msg_resp_query_fw_caps {
 #define MSG_FLAG_CAPS_LPM_STANDBY	TI_SCI_MSG_FLAG(3)
 #define MSG_FLAG_CAPS_LPM_PARTIAL_IO	TI_SCI_MSG_FLAG(4)
 #define MSG_FLAG_CAPS_LPM_DM_MANAGED	TI_SCI_MSG_FLAG(5)
+#define MSG_FLAG_CAPS_LPM_ENCRYPT_IMAGE	TI_SCI_MSG_FLAG(11)
	uint64_t fw_caps;
 } __packed;

@@ -810,4 +814,32 @@ struct ti_sci_msg_resp_lpm_get_next_sys_mode {
	uint8_t mode;
 } __packed;

+/*
+ * struct ti_sci_msg_req_encrypt_tfa - Request for TISCI_MSG_LPM_ENCRYPT_TFA.
+ *
+ * @hdr			Generic Header
+ * @src_tfa_addr:  Address where the TFA lies unencrypted
+ * @src_tfa_len:   Size of the TFA unencrypted
+ *
+ * This message is to be sent when the system is going in suspend, just before
+ * TI_SCI_MSG_ENTER_SLEEP.
+ * The TIFS will then encrypt the TFA and store it in RAM, along with a private
+ * header.
+ * Upon resume, the SPL will ask TIFS to decrypt it back.
+ */
+struct ti_sci_msg_req_encrypt_tfa {
+	struct ti_sci_msg_hdr hdr;
+	uint64_t src_tfa_addr;
+	uint32_t src_tfa_len;
+} __packed;
+
+/*
+ * struct ti_sci_msg_req_encrypt_tfa - Request for TISCI_MSG_LPM_ENCRYPT_TFA.
+ *
+ * @hdr			Generic Header
+ */
+struct ti_sci_msg_resp_encrypt_tfa {
+	struct ti_sci_msg_hdr hdr;
+} __packed;
+
 #endif /* TI_SCI_PROTOCOL_H */
diff --git a/plat/ti/k3/common/k3_psci.c b/plat/ti/k3/common/k3_psci.c
index a443dd851..c2017666b 100644
--- a/plat/ti/k3/common/k3_psci.c
+++ b/plat/ti/k3/common/k3_psci.c
@@ -24,6 +24,7 @@
 #define SYSTEM_PWR_STATE(state) ((state)->pwr_domain_state[PLAT_MAX_PWR_LVL])

 uintptr_t k3_sec_entrypoint;
+bool encrypt_image;

 static void k3_cpu_standby(plat_local_state_t cpu_state)
 {
@@ -282,6 +283,11 @@ static void k3_pwr_domain_suspend_to_mode(const psci_power_state_t *target_state
	k3_gic_cpuif_disable();
	k3_gic_save_context();

+	if (encrypt_image)
+	{
+		ti_sci_encrypt_tfa((uint64_t)__TEXT_START__, BL31_SIZE);
+	}
+
	k3_pwr_domain_off(target_state);

	ti_sci_enter_sleep(proc_id, mode, k3_sec_entrypoint);
@@ -347,6 +353,10 @@ int plat_setup_psci_ops(uintptr_t sec_entrypoint,
		ERROR("Unable to query firmware capabilities (%d)\n", ret);
	}

+	if (fw_caps & MSG_FLAG_CAPS_LPM_ENCRYPT_IMAGE) {
+		encrypt_image = true;
+	}
+
	/* If firmware does not support any known suspend mode */
	if (!(fw_caps & (MSG_FLAG_CAPS_LPM_DEEP_SLEEP |
			 MSG_FLAG_CAPS_LPM_MCU_ONLY |
--
2.34.1
